%MARBLEPLOT   Calculate marble-in-a-cup potential plot (1D model)
%   In one dimensional models you can represent the stability of equilibria as
%   potential landscape with hills and valleys. The landscape can be generated by 
%   solving the potential function of the model:
%   dx/dt=f(x)
%   transform this model to the potential equation:
%   -dV/dx=f(x)
%   The simulation of this model (initial condition=0) gives the stability plot at several values of 
%   a parameter, to create a plot comparable as in Scheffer et al. 2001 
%   (Nature 413: 591-596). The current state is often represented by a marble, but one should imagine
%   that this marble is heavily damped and sliding through a greasy substance (Strogatz, 1994).
%   
%   Usage:
%   MARBLEPLOT - the user is asked to enter the required information.
%   MARBLEPLOT NPOT PAR [MINPAR,MAXPAR] VAR [MINVAR, MAXPAR] - NPOT= the number of
%   stability lines, PAR = name of control parameter; [MINPAR, MAXVAR]= range of 
%   parameter; VAR = state variable; [MINVAR MAXVAR] range of state variable.
%   MARBLEPLOT('argname',argvalue,...) - Valid argument <a href="matlab:commands func_args">name-value pairs</a> [with type]:
%     'maxcolor' [number and length(number)==3] - Color of the last landscape
%     'mincolor' [number and length(number)==3] - Color of the first landscape
%     'npot' [integer>0] - Number of potentials; par: parameter to change
%     'opaqueness' [number>=0 and number<=1] - Opaqueness (see <a href="matlab:help alpha">alpha</a>)
%     'par' [parameter] - Name of the control parameter
%     'patchheight' [number] - Relative height of the minimum potential
%     'potdata' [general] - Use external data for the potentials
%     'rangepar' [number and length(number)==2] - Range of the parameter
%     'rangepot' [number and length(number)==2 or empty] - Range for the potentials to be plotted
%     'rangevar' [number and length(number)==2] - Range of state variable
%     'showballs' [logical] - Show "balls" in the landscape
%     'stemlength' [number] - Relative length of the stems
%     'var' [state variable] - State variable
%     'varzero' [minpot | maxpot | minvar | maxvar or number] - How scale the potentials
%   MARBLEPLOT('-opt1','-opt2',...) - Valid command line <a href="matlab:commands func_args">options</a>:
%     '-o' - get structure with default settings
%
%  
%   See also potential, null, ax
%
%   Reference page in Help browser:
%      <a href="matlab:commands('marbleplot')">commands marbleplot</a>

%   Copyright 2019 WUR
%   Revision: 1.2.1 $ $Date: 15-Jul-2019 21:00:40 $
function res = marbleplot(varargin)
% (npot, par, rangepar, statevar, rangestatevar,varzero, ...
%    stemlength, patchheight, mincolor, maxcolor, opaqueness)
global g_grind;
if nargin==0
    varargin={'??dlgnoopt'};
end
%get default options
if isfield(g_grind, 'marbleplot')
    defaults=g_grind.marbleplot;
else
    if isempty(g_grind)
        xlim=[];
        ylim=[];
        par='';
        statevar='';
        if ~exist('i_use','file')
            addpath([grindpath filesep 'sys2']);
        end
    else
        par = g_grind.xaxis.var;
        iX = i_getno(par);
        if (isempty(iX) || (~iX.ispar)) && (~isempty(g_grind.pars))
            par = g_grind.pars{1};
            statevar = g_grind.xaxis.var;
        else
            statevar = g_grind.yaxis.var;
        end       
        xlim=g_grind.xaxis.lim;
        ylim=g_grind.yaxis.lim;
    end
    defaults=struct('npot', 5,'par', par,'rangepar',xlim,'var', ...
        statevar,'rangevar',ylim,'varzero','minpot',...
        'stemlength',1,'patchheight',0.1,'mincolor',[0.8 0.8 0.8],...
        'maxcolor',[0.5 0.5 0.5],'opaqueness',0.9,'showballs',false,'potdata',[],'rangepot',[]);
end

fieldnams={'maxcolor', 'n&length(n)==3', 'Color of the last landscape',defaults.maxcolor;...
    'mincolor', 'n&length(n)==3', 'Color of the first landscape',defaults.mincolor;...
    'npot', 'i>0', 'Number of potentials; par: parameter to change',defaults.npot;...
    'opaqueness', 'n>=0&n<=1', 'Opaqueness (see <a href="http://www.mathworks.nl/help/matlab/ref/alpha.html">alpha</a>)<br>',defaults.opaqueness;...
    'par', 'p', 'Name of the control parameter',defaults.par;...
    'patchheight', 'n', 'Relative height of the minimum potential',defaults.patchheight;...
    'potdata', '', 'Use external data for the potentials',defaults.potdata;...
    'rangepar', 'n&length(n)==2', 'Range of the parameter',defaults.rangepar;...
    'rangepot', 'n&length(n)==2#E', 'Range for the potentials to be plotted',defaults.rangepot;...
    'rangevar', 'n&length(n)==2', 'Range of state variable',defaults.rangevar;...
    'showballs', 'l', 'Show "balls" in the landscape',defaults.showballs;...
    'stemlength', 'n', 'Relative length of the stems',defaults.stemlength;...
    'var', 'v', 'State variable',defaults.var;...
    'varzero', 'e[minp+ot|maxp+ot|minv+ar|maxv+ar]#n', 'How scale the potentials',defaults.varzero}';
args=i_parseargs(fieldnams,'npot,par,rangepar,var,rangevar','-o',varargin);
addplain = 0; %doesn't work correctly
if any(strcmp(args.opts, '-o'))
    res=defaults;
    return;
end
args=mergestructs(defaults,args);
g_grind.marbleplot=args;
pots = cell(1, args.npot);
xs =  cell(1, args.npot);
ps =  cell(1, args.npot);
maxpot = -9999;
minpot = 9999;
if ~isempty(args.potdata)
    pots = args.potdata.pots;
    xs = args.potdata.xs;
    ps = args.potdata.ps;
    if ~isempty(g_grind)
        hfig = i_figure([],g_grind.figopts{:});
    else
        hfig = i_figure([]);
    end
    args.npot=length(pots);
    if isempty(args.rangepar)
        pars=zeros(size(ps));
        for i=1:args.npot
            pars(i)=ps{i}(1);
        end
        args.rangepar=[min(pars), max(pars)];
        args.rangevar=[min(xs{1}), max(xs{1})];
    end
    ylabel(args.var);
    xlabel(args.par);
else
    oldxax = g_grind.xaxis;
    oldyax = g_grind.yaxis;
    oldzax = g_grind.zaxis;
    oldpar = evalin('base', args.par);
    try
        iX = i_getno(args.par);
        if isempty(iX) || ~iX.ispar
            error('GRIND:marbleplot:NoPar','"%s" is not a parameter',args.par);
        end
        iX = i_getno(args.var);
        if isempty(iX) || ~iX.isvar
            error('GRIND:marbleplot:NoStatevar','"%s" is not a state variable',args.var);
        end
        ax('x', args.par, args.rangepar);
        ax('y', args.var, args.rangevar);
        ax('z');
        null 100;
        legend off;
        set(get(gca,'children'),'linestyle','-','tag','nullplot')
        hold on;
        hfig = gcf;
        %get potentials
        for i = 1:args.npot
            apar = args.rangepar(1) + (args.rangepar(2) - args.rangepar(1)) * (i - 1) / (args.npot - 1);
            assignin('base', args.par, apar);
            [x, pot] = potential;
            pots{i} = pot;
            xs{i} = x;
            ps{i} = ones(size(x)) * apar;
        end
        if addplain
            potplain = zeros(50, 50);
            xplain = zeros(50, 50);
            pplain = zeros(50, 50);
            for i = 1:50
                apar = args.rangepar(1) + (args.rangepar(2) - args.rangepar(1)) * (i - 1) / (50 - 1);
                assignin('base', args.par, apar);
                [x, pot] = potential;
                potplain(i, :) = pot;
                xplain(i, :) = x;
                pplain(i, :) = ones(size(x)) * apar;
            end
            for i = 1:50
                switch args.varzero
                    case 'minpot'
                        potplain(i, :) = potplain(i, :) - min(min(potplain(i, :))) + 1;
                    case 'maxpot'
                        potplain(i, :) = potplain(i, :) - max(max(potplain(i, :))) + 1;
                    case 'minvar'
                        potplain = potplain(i, :) - potplain(i, :) + 1;
                    case 'maxvar'
                        potplain = potplain(i, :) - potplain(:, end) + 1;
                    otherwise
                        if ischar(args.varzero)
                            vardif = abs(xplain(i, :) - str2double(args.varzero));
                        else
                            vardif = abs(xplain(i, :) - args.varzero);
                        end
                        potplain(i, :)=potplain(i, :) - potplain(i, vardif == min(vardif)) + i;
                end
            end
        end
        g_grind.xaxis = oldxax;
        g_grind.yaxis = oldyax;
        g_grind.zaxis = oldzax;
        assignin('base', args.par, oldpar);
    catch err
        %   err=lasterror;
        g_grind.xaxis = oldxax;
        g_grind.yaxis = oldyax;
        g_grind.zaxis = oldzax;
        assignin('base', args.par, oldpar);
        rethrow(err);
    end
end
%analyse/scale potentials
for i = 1:args.npot
    pot = pots{i};
    switch args.varzero
        case 'minpot'
            pot = pot - min(pot) + 1;
        case 'maxpot'
            pot = pot - max(pot) + 1;
        case 'minvar'
            pot = pot - pot(1) + 1;
        case 'maxvar'
            pot = pot - pot(end) + 1;
        otherwise
            if ischar(args.varzero)
                vardif = abs(xs{i} - str2double(args.varzero));
            else
                vardif = abs(xs{i} - args.varzero);
            end
            pot=pot - pot(vardif == min(vardif)) + i;
    end
    if ~isempty(args.rangepot)
        pot=max(pot,zeros(size(pot))+args.rangepot(1));
        pot=min(pot,zeros(size(pot))+args.rangepot(2));
    end
    pots{i} = pot;
    m = max(pot);
    if m > maxpot
        maxpot = m;
    end
    m = min(pot);
    if m < minpot
        minpot = m;
    end
end
%scale pots between stemlength and stemlength+1
for i = 1:args.npot
    pots{i} = (pots{i} - minpot) / (maxpot - minpot) + args.stemlength;
end
if addplain
    potplain = (potplain-minpot) / (maxpot - minpot) + args.stemlength;
end
offset = args.stemlength;
minpatch  = args.stemlength - args.patchheight;
hold on;
plot3([args.rangepar(1), args.rangepar(1), args.rangepar(2), args.rangepar(2)], ...
    [args.rangevar(1),args.rangevar(2),args.rangevar(2),args.rangevar(1)],[0, 0, 0, 0],'k-');
% if args.showballs
%    [sphx, sphy, sphz] = sphere(10);
% end
for i = args.npot:-1:1 % from the back to the front
    i_figure(hfig);
    apar = ps{i}(1);
    xx = [apar; ps{i}(:); apar];
    yy = [args.rangevar(1); xs{i}(:); args.rangevar(2)];
    zz = [minpatch; pots{i}(:) ; minpatch];
    color = args.mincolor + (args.maxcolor - args.mincolor) / (args.npot - 1) * (i - 1);
    %     gr = 0.5 + (npot - i + 1) / 2 / (npot + 1);
    h = patch(xx, yy, zz, color);
    alpha(h, args.opaqueness)
    set(h, 'linewidth', 1);
    hold on;
    plot3([apar, apar, apar, apar], [args.rangevar(1), args.rangevar(1), args.rangevar(2), args.rangevar(2)], ...
        [minpatch, 0 ,0, minpatch], 'k--');
    i_plotdefaults(hfig);
    ax1  = pots{i}(:);
    minindex = find( diff( sign( diff([ax1(1); ax1; ax1(end)]) ) ) > 0 );
    if (~isempty(minindex))
        if args.showballs
            for j=1:length(minindex)
                drawball(gca, xs{i}(minindex(j)), apar,xs{i}(minindex(j)), ax1(minindex(j)));
            end
            %          for k = 1:length(minindex)
            %             diam = 0.02;
            %             xlims = args.rangepar; ylims = args.rangevar; zlims = [0, offset + 1];
            %             surf(apar + sphx * diam * (xlims(2) - xlims(1)), ...
            %                xs{i}(minindex(k)) + sphy * 0.03 * (ylims(2) - ylims(1)), ax1(minindex(k)) + ...
            %                diam * 1.01 * abs(zlims(2) - zlims(1)) + sphz * diam * (zlims(2) - zlims(1)));
            %             colormap(gca, [0.3 0.3 0.3]);
            %          end
        else
            h= plot3(apar * ones(size(minindex)), xs{i}(minindex), ax1(minindex),'ko');
            set(h,'MarkerFaceColor','k')
            %    shading(gca,'flat')
        end
    end
end
if addplain
    surf(pplain, xplain, potplain);
    colormap gray;
end
if ~isoctave&&verLessThan('matlab','8.4.0')
    set(gca, 'drawmode','fast');
else
    set(gca,'SortMethod','depth');
end
set(gca, 'View', [  - 68 20]);
if args.rangepar(1) > args.rangepar(2)
    set(gca, 'View', [105 20]);
end
set(gca, 'Zlim', [0, offset + 1]);
set(gca, 'ZTick', []);
set(gca, 'ZTickLabel', [])
box off;

function h=drawball(hax, xpos, pars,Xs, V)
oldhold = ishold(hax);
hold(hax, 'on')
pos = ballpos(hax, xpos, Xs, V);
h = zeros(2, 1);
pos1 = getpixelposition(gca);
h(1)=scatter3(hax,pars(1),pos(1,1),pos(1,2),200/525.5*pos1(4),'k','markerfacecolor','k','tag','bigball');
h(2)=scatter3(hax,pars(1),pos(2,1),pos(2,2),3.7/525.5*pos1(4),'w','markerfacecolor','w','tag','smallball');

if ~oldhold
    hold(hax, 'off');
end


function pos = ballpos(hax, xpos, Xs, V)
ylim = get(hax, 'ylim');
xlim = get(hax, 'xlim');
pos = zeros(2);
pos(1, 1) = xpos;
if numel(V)==1
    
    pos(1, 2) = V + (ylim(2) - ylim(1)) * (0.031+0.02);
    pos(2, 2) = V + (ylim(2) - ylim(1)) * (0.03+0.04);
else
    pos(1, 2) = interp1(Xs, V, xpos) + (ylim(2) - ylim(1)) * 0.031;
    pos(2, 2) = interp1(Xs, V, xpos) + (ylim(2) - ylim(1)) * 0.04;
end
pos(2, 1) = xpos + (xlim(2) - xlim(1)) * 0.005;

